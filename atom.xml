<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://hjxhjx-hub.github.io/</id>
    <title>hjx的小窝</title>
    <updated>2021-09-26T13:34:34.633Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://hjxhjx-hub.github.io/"/>
    <link rel="self" href="https://hjxhjx-hub.github.io/atom.xml"/>
    <subtitle>Think twice, code once</subtitle>
    <logo>https://hjxhjx-hub.github.io/images/avatar.png</logo>
    <icon>https://hjxhjx-hub.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, hjx的小窝</rights>
    <entry>
        <title type="html"><![CDATA[A*、IDA*、k短路学习笔记]]></title>
        <id>https://hjxhjx-hub.github.io/post/A-star/</id>
        <link href="https://hjxhjx-hub.github.io/post/A-star/">
        </link>
        <updated>2021-09-26T12:30:41.000Z</updated>
        <content type="html"><![CDATA[<h2 id="a">A*</h2>
<p>在求最短路的过程中，可以使用 bfs 等算法。</p>
<p>但是有时现在的代价已经不可能会是最优解了，或者是难以找到最优解了，但是我们还在继续搜索，这样就必然会造成资源的浪费。</p>
<p>怎么办呢？我们可以引入一种算法 「A*」，启发式搜索。</p>
<p>A* 与 bfs 基本一致，但是加入了一些很神奇的优化（这里不放代码了，直接看 bfs 的代码理解一下就行了）。</p>
<p>在 A* 中，我们定义估价函数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>+</mo><mi>h</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(x) = g(x) + h(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> 表示从起点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span> ，经过点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>，到达终点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">e</span></span></span></span> 的<strong>估计代价</strong>。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">g(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> 表示从起点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span> 到点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 的<strong>实际代价</strong>。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">h(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> 表示从点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 到终点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">e</span></span></span></span> 的<strong>估计代价</strong>。</p>
<p>求出了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">h(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>，我们便可以按照 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> ，从小到大有顺序地搜索了。</p>
<p>看下图：</p>
<figure data-type="image" tabindex="1"><img src="https://hjxhjx-hub.github.io//post-images/1632659491697.png" alt="" loading="lazy"></figure>
<p>左上角为迷宫的入口，右下角为出口</p>
<p>而右边的数字是每种颜色所代表的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">h(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>。</p>
<p>这时可能就有人要问了：你这估的价怎么能穿墙啊（<s>形象理解一下这句话，实在找不到更好的措辞了</s>）</p>
<p>因为我没有时间提前跑一遍迷宫来使得 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><msup><mi>h</mi><mo>∗</mo></msup><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">h(x)=h^*(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span></p>
<p>所以我们可以这样简单地预处理一遍 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">h(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> 来获得一定程度上的优化。</p>
<p><strong>但是且慢</strong></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">h(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> 用哪种方法求都行吗？<s>（rand）</s></p>
<p>...差不多吧，但是要满足 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>≤</mo><msup><mi>h</mi><mo>∗</mo></msup><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">h(x) \le h^*(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span></p>
<p>这里的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>h</mi><mo>∗</mo></msup><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">h^*(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> 是指从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 到终点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">e</span></span></span></span> 的<strong>实际代价</strong></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">h(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> 越接近 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>h</mi><mo>∗</mo></msup><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">h^*(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>，程序的效率就越高，走的弯路就越少。</p>
<p>现在想象一道题目，要求最短路。</p>
<p>我们先从终点开始跑一遍 Dijkstra，求出每个点到终点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span> 的距离，作为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">h(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>（即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><msup><mi>h</mi><mo>∗</mo></msup><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">h(x) = h^*(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>）</p>
<p>然后我们再跑一遍 A* ，就可以沿着上次找到的最短路直接找到终点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span> 了</p>
<p><s>是不是一种特别有意义的算法</s></p>
<p>显然上面这东西确实没啥意义（因为我们第一次跑 Dijkstra 就已经把最短路求出来了）</p>
<p>但是请记住它。</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow></mrow><annotation encoding="application/x-tex"></annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span></span></p>
<h2 id="ida">IDA*</h2>
<p>A* 是针对 bfs 的优化，那既然是搜索，怎能缺了我们的 dfs 呢？</p>
<p>如果 dfs 不好优化，那我们为什么不把它改造成 bfs 呢？</p>
<p>于是 「 IDA*」，迭代加深+启发式搜索就出现了。</p>
<p>考虑一道题目必须使用 dfs，且此题需要求最小的可以解决问题的迭代深度。</p>
<p>例如 <a href="https://www.luogu.com.cn/problem/P2324"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="#3498DB"><mi mathvariant="monospace">P</mi><mn mathvariant="monospace">2324</mn><mtext> </mtext><mo>[</mo><mi mathvariant="monospace">S</mi><mi mathvariant="monospace">C</mi><mi mathvariant="monospace">O</mi><mi mathvariant="monospace">I</mi><mn mathvariant="monospace">2005</mn><mo>]</mo><mtext> </mtext><mstyle mathsize="0.9em"><mtext>骑士精神</mtext></mstyle></mstyle></mrow><annotation encoding="application/x-tex">\tt\color{#3498DB} P2324~[SCOI2005]~\text{\small 骑士精神}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathtt" style="color:#3498DB;">P</span><span class="mord mathtt" style="color:#3498DB;">2</span><span class="mord mathtt" style="color:#3498DB;">3</span><span class="mord mathtt" style="color:#3498DB;">2</span><span class="mord mathtt" style="color:#3498DB;">4</span><span class="mspace nobreak" style="color:#3498DB;"><span style="color:#3498DB;"> </span></span><span class="mopen" style="color:#3498DB;">[</span><span class="mord mathtt" style="color:#3498DB;">S</span><span class="mord mathtt" style="color:#3498DB;">C</span><span class="mord mathtt" style="color:#3498DB;">O</span><span class="mord mathtt" style="color:#3498DB;">I</span><span class="mord mathtt" style="color:#3498DB;">2</span><span class="mord mathtt" style="color:#3498DB;">0</span><span class="mord mathtt" style="color:#3498DB;">0</span><span class="mord mathtt" style="color:#3498DB;">5</span><span class="mclose" style="color:#3498DB;">]</span><span class="mspace nobreak" style="color:#3498DB;"><span style="color:#3498DB;"> </span></span><span class="mord text" style="color:#3498DB;"><span class="mord cjk_fallback sizing reset-size6 size5" style="color:#3498DB;">骑士精神</span></span></span></span></span></span></a>。</p>
<p>显然此题我们可以直接移动格子...</p>
<p>考虑爆搜并统计答案，显然会炸，因为我们可能会在一条不会出现答案/深度不是最优的方案上徘徊许久，造成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><menclose mathbackground="#052242"><mstyle mathcolor="white"><mtext mathvariant="monospace">TLE</mtext></mstyle></menclose></mrow><annotation encoding="application/x-tex">\colorbox{#052242}{\color{white}\tt TLE}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2111100000000001em;vertical-align:-0.3em;"></span><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9111100000000001em;"><span style="top:-2.9111100000000003em;"><span class="pstrut" style="height:3.21111em;"></span><span class="stretchy colorbox" style="height:1.2111100000000001em;background-color:#052242;"></span></span><span style="top:-3.21111em;"><span class="pstrut" style="height:3.21111em;"></span><span class="mord boxpad"><span class="mord" style="color:white;"><span class="mord mathtt" style="color:white;">T</span><span class="mord mathtt" style="color:white;">L</span><span class="mord mathtt" style="color:white;">E</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3em;"><span></span></span></span></span></span></span></span></span></p>
<p>现在我们可以考虑定义 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mi>d</mi><mi>e</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">maxdep</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">p</span></span></span></span> 为最大的迭代深度，如果当前的迭代代价 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>&gt;</mo><mi>m</mi><mi>a</mi><mi>x</mi><mi>d</mi><mi>e</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">g(x) &gt; maxdep</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">p</span></span></span></span>，那么就直接结束。（现在是不是已经有 bfs 的感觉了？）</p>
<p>于是我们现在可以枚举 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mi>d</mi><mi>e</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">maxdep</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">p</span></span></span></span>，依次都执行一遍 dfs，这就是迭代加深，也就是 IDA* 中的 ID。</p>
<p>所以 ID 写完了，A* 也就是普通的启发式搜索了。由于我们的没必要使得严格使得估价函数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><msup><mi>h</mi><mo>∗</mo></msup><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">h(x)=h^*(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>（毕竟是<strong>估</strong>价嘛）</p>
<p>所以本题的估价函数可以直接统计当前状态与期望的地图中不同的格子。</p>
<p>对于一个状态，我们可以当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>&gt;</mo><mi>m</mi><mi>a</mi><mi>x</mi><mi>d</mi><mi>e</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">f(x) &gt; maxdep</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">p</span></span></span></span> 时直接回溯，避免了运算资源的投入。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathsize="0.5em"><mtext mathvariant="monospace">（以上是我在题解中找到的写法。经过我的思考，又发现以下这种优化方法。）</mtext></mstyle></mrow><annotation encoding="application/x-tex">\tiny\texttt{（以上是我在题解中找到的写法。经过我的思考，又发现以下这种优化方法。）}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.305555em;vertical-align:0em;"></span><span class="mord text sizing reset-size6 size1"><span class="mord texttt cjk_fallback">（以上是我在题解中找到的写法。经过我的思考，又发现以下这种优化方法。）</span></span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathsize="0.5em"><mtext mathvariant="monospace">（介于本人水平太菜，这种方法可能并不能起到优化的作用。）</mtext></mstyle></mrow><annotation encoding="application/x-tex">\tiny\texttt{（介于本人水平太菜，这种方法可能并不能起到优化的作用。）}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.305555em;vertical-align:0em;"></span><span class="mord text sizing reset-size6 size1"><span class="mord texttt cjk_fallback">（介于本人水平太菜，这种方法可能并不能起到优化的作用。）</span></span></span></span></span></p>
<p>仔细观察题目，可以发现最大迭代深度是具有单调性的，如果最大迭代深度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>114514</mn></mrow><annotation encoding="application/x-tex">114514</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mord">4</span><span class="mord">5</span><span class="mord">1</span><span class="mord">4</span></span></span></span> 可以解决问题，那么最大迭代深度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1919810</mn></mrow><annotation encoding="application/x-tex">1919810</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">9</span><span class="mord">1</span><span class="mord">9</span><span class="mord">8</span><span class="mord">1</span><span class="mord">0</span></span></span></span> 也一定可以解决问题。</p>
<p>那么我们就可以给 dfs 再套上一层二分了</p>
<p>最后成功 <a href="https://www.luogu.com.cn/record/53693338"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><menclose mathbackground="#52C41A"><mstyle mathcolor="white"><mtext mathvariant="monospace">AC</mtext></mstyle></menclose></mrow><annotation encoding="application/x-tex">\colorbox{#52C41A}{\tt\color{white}AC}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2111100000000001em;vertical-align:-0.3em;"></span><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9111100000000001em;"><span style="top:-2.9111100000000003em;"><span class="pstrut" style="height:3.21111em;"></span><span class="stretchy colorbox" style="height:1.2111100000000001em;background-color:#52C41A;"></span></span><span style="top:-3.21111em;"><span class="pstrut" style="height:3.21111em;"></span><span class="mord boxpad"><span class="mord"><span class="mord mathtt" style="color:white;">A</span><span class="mord mathtt" style="color:white;">C</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3em;"><span></span></span></span></span></span></span></span></span></a></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow></mrow><annotation encoding="application/x-tex"></annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span></span></p>
<h2 id="k短路">k短路</h2>
<p>在一些题目中，我们可能需要求的不是最短路，而是第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 短的路</p>
<p><s>还是简单好吧，我直接 bfs 记录第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><menclose notation="horizontalstrike"><mi>k</mi></menclose></mrow><annotation encoding="application/x-tex">\sout k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span><span style="top:-3.2155em;"><span class="pstrut" style="height:3em;"></span><span class="stretchy sout"></span></span></span></span></span></span></span></span></span>个到终点的不就行了</s></p>
<p>是的，确实行了，但是你可曾想过被卡掉的风险？</p>
<p>于是 A* 闪亮登场。</p>
<p>还记得 A* 一节的末尾我讲到的那种没意义的方法吗，</p>
<p>是的，它回来了，还带给了我们些许启发（<s>不愧是启发式搜索</s>）！</p>
<p>看这道题目：<a href="https://www.luogu.com.cn/problem/P2901"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="#9D3DCF"><mtext> </mtext><mi mathvariant="monospace">P</mi><mn mathvariant="monospace">2901</mn><mtext> </mtext><mo>[</mo><mi mathvariant="monospace">U</mi><mi mathvariant="monospace">S</mi><mi mathvariant="monospace">A</mi><mi mathvariant="monospace">C</mi><mi mathvariant="monospace">O</mi><mn mathvariant="monospace">08</mn><mtext> </mtext><mi mathvariant="monospace">M</mi><mi mathvariant="monospace">A</mi><mi mathvariant="monospace">R</mi><mo>]</mo><mi mathvariant="monospace">C</mi><mi mathvariant="monospace">o</mi><mi mathvariant="monospace">w</mi><mtext> </mtext><mi mathvariant="monospace">J</mi><mi mathvariant="monospace">o</mi><mi mathvariant="monospace">g</mi><mi mathvariant="monospace">g</mi><mi mathvariant="monospace">i</mi><mi mathvariant="monospace">n</mi><mi mathvariant="monospace">g</mi><mtext> </mtext><mstyle mathsize="0.9em"><mstyle mathcolor="gold"><mi mathvariant="monospace">G</mi></mstyle></mstyle></mstyle></mrow><annotation encoding="application/x-tex">\tt\color{#9D3DCF}\ P2901~[USACO08~MAR] Cow~Jogging~\small\color{gold} G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mspace" style="color:#9D3DCF;"><span style="color:#9D3DCF;"> </span></span><span class="mord mathtt" style="color:#9D3DCF;">P</span><span class="mord mathtt" style="color:#9D3DCF;">2</span><span class="mord mathtt" style="color:#9D3DCF;">9</span><span class="mord mathtt" style="color:#9D3DCF;">0</span><span class="mord mathtt" style="color:#9D3DCF;">1</span><span class="mspace nobreak" style="color:#9D3DCF;"><span style="color:#9D3DCF;"> </span></span><span class="mopen" style="color:#9D3DCF;">[</span><span class="mord mathtt" style="color:#9D3DCF;">U</span><span class="mord mathtt" style="color:#9D3DCF;">S</span><span class="mord mathtt" style="color:#9D3DCF;">A</span><span class="mord mathtt" style="color:#9D3DCF;">C</span><span class="mord mathtt" style="color:#9D3DCF;">O</span><span class="mord mathtt" style="color:#9D3DCF;">0</span><span class="mord mathtt" style="color:#9D3DCF;">8</span><span class="mspace nobreak" style="color:#9D3DCF;"><span style="color:#9D3DCF;"> </span></span><span class="mord mathtt" style="color:#9D3DCF;">M</span><span class="mord mathtt" style="color:#9D3DCF;">A</span><span class="mord mathtt" style="color:#9D3DCF;">R</span><span class="mclose" style="color:#9D3DCF;">]</span><span class="mord mathtt" style="color:#9D3DCF;">C</span><span class="mord mathtt" style="color:#9D3DCF;">o</span><span class="mord mathtt" style="color:#9D3DCF;">w</span><span class="mspace nobreak" style="color:#9D3DCF;"><span style="color:#9D3DCF;"> </span></span><span class="mord mathtt" style="color:#9D3DCF;">J</span><span class="mord mathtt" style="color:#9D3DCF;">o</span><span class="mord mathtt" style="color:#9D3DCF;">g</span><span class="mord mathtt" style="color:#9D3DCF;">g</span><span class="mord mathtt" style="color:#9D3DCF;">i</span><span class="mord mathtt" style="color:#9D3DCF;">n</span><span class="mord mathtt" style="color:#9D3DCF;">g</span><span class="mspace nobreak" style="color:#9D3DCF;"><span style="color:#9D3DCF;"> </span></span><span class="mord mathtt sizing reset-size6 size5" style="color:gold;">G</span></span></span></span></span></a></p>
<p>题意就是求一个有向图上的，从点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 到点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的前 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 短路。</p>
<p>结合那个没啥意义的算法，你应该知道怎么求了吧</p>
<p>先建一张反向的图，然后随便跑个最短路求出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">h(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span></p>
<p>然后跑一遍 A*，每当出队的是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> （终点）就输出距离，然后就没有然后了。</p>
<p>由于刚才我们求 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">h(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> 跑的是最短路<s>而不是rand</s>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><msup><mi>h</mi><mo>∗</mo></msup><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">h(x) = h^*(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>，所以 A* 的效率会奇快，然后就直接把这题切掉了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 P4911【河童重工的计算机】]]></title>
        <id>https://hjxhjx-hub.github.io/post/solution-p4911/</id>
        <link href="https://hjxhjx-hub.github.io/post/solution-p4911/">
        </link>
        <updated>2021-09-26T12:30:07.000Z</updated>
        <summary type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P4911">题目传送门</a></p>
]]></summary>
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P4911">题目传送门</a></p>
<!-- more -->
<h2 id="题意简述">题意简述</h2>
<ul>
<li>给出一段汇编语言。</li>
<li>给出输入。</li>
<li>求这段汇编语言的输出。</li>
</ul>
<p>以下还有一些题面中没有强调的要点：</p>
<ol>
<li>每行只有一条语句；</li>
<li><code>call &lt;0&gt;;</code> 命令会将下一行的序号 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>x</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">nxt</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">x</span><span class="mord mathdefault">t</span></span></span></span> 与当前的寄存器 <code>%Line</code> 的值 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>i</mi><mi>n</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">line</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span></span></span></span> 压入栈中；</li>
<li><code>ret &lt;0&gt;;</code> 命令会从栈中取出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>x</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">nxt</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">x</span><span class="mord mathdefault">t</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>i</mi><mi>n</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">line</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span></span></span></span>，并使程序跳转到第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>x</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">nxt</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">x</span><span class="mord mathdefault">t</span></span></span></span> 行，同时将当前的 <code>%Line</code> 赋值为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>i</mi><mi>n</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">line</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span></span></span></span>；</li>
<li>逗号等于空格；</li>
<li>内存的地址是一个十进制的数字，从0开始；</li>
<li>关键字全是小写，但函数名不一定；</li>
<li>注释可以嵌套；</li>
<li>数据<strong>非常简单</strong>，不用考虑那些奇奇怪怪的情况。</li>
</ol>
<h2 id="题目分析">题目分析</h2>
<p>显而易见的，本题是个大模拟题。</p>
<p>先铺垫 c++ 的几个不常用（？）的特性：</p>
<ul>
<li>在定义函数时，如 <code>int function(int f=1)</code>，这里的 <code>f=1</code> 表示「默认」。当我给该函数参数时，<code>f</code> 的默认取值 <code>1</code> 会被覆盖，若我不给参数，则 <code>f</code> 会取默认值。</li>
<li>如果定义了变量 <code>a</code> ，则 <code>*a</code> 可以理解为「指向 <code>a</code> 的指针」。</li>
<li><code>sscanf()</code> 可以从字符串中读取数据。</li>
</ul>
<p>本题思维难度不大，其难度主要体现在实现以及码量上。</p>
<p>读懂了题目，那么接下来我们就可以快乐地给汇编语言写解释器了。</p>
<p>题面中提到了一套完整的内存系统，唯有先将它实现好了，才能继续进行工作。</p>
<h3 id="地址系统">地址系统</h3>
<p>考虑如何实现寄存器和内存…啊不用考虑，太简单了，直接开几个变量和一个数组就行了。</p>
<p>但是内存系统的难点就在处理那些字符串上。</p>
<p>既然题干中指令会对内存甚至是常量进行读写，那我们直接获取指针就好了。</p>
<p>因此，我们可以考虑实现一个函数 <code>int*get_address(string address)</code>。</p>
<ul>
<li>对于寄存器和固定位置的内存（“%” 与 “@”），我们直接返回其指针。</li>
<li>对于在寄存器值位置的内存（“@%”），我们先获取该寄存器的值，再返回对应位置内存的指针。</li>
<li>对于编译时常量与普通常量（“#” 与数字），考虑到命令会对常量进行修改，所以我们可以定义一个变量，赋上常量的值，然后返回该变量的指针。</li>
</ul>
<p>然后就写好了：</p>
<pre><code class="language-cpp">int R1,R2,R3,R4; //寄存器
int E1,E2,E3,E4; //寄存器
int Flag,Val,Ret,Line; //寄存器 
int memory[20000000]; //内存 
int undefine; //对常量的修改 
struct node{
    int nxtline,Line;
    node(int nn,int ll){
        nxtline=nn,Line=ll;
    }
};
stack&lt;node&gt; sAddr; //系统栈 
string code[50005]; //汇编 
int nowline; //当前执行到的行数 

int get_int(string s,bool ch){ //将 字符串/字符 转化为数字
    if(ch) return s[0];
    int res=0;bool neg=0; 
    if(s[0] == '-') neg=1;
    for(int i=(neg?1:0);i&lt;(int)s.size();i++) res=(res&lt;&lt;1)+(res&lt;&lt;3)+(s[i]^48);
    return (neg?-res:res);
}

string get_str(int x){ //将数字转化为字符串
    string res=&quot;&quot;;
    bool neg=0;
    if(x&lt;0) neg=1,x=-x;
    while(x&gt;0){
        res+=((x%10)^48);
        x/=10;
    }
    reverse(res.begin(),res.end());
    if(neg) return &quot;-&quot;+res;
    return res;
}

int*get_address(string address){
    if(address[0] == '%'){ //寄存器 
        address = address.substr(1);
        if(address == &quot;r1&quot;) return&amp;R1;
        if(address == &quot;r2&quot;) return&amp;R2;
        if(address == &quot;r3&quot;) return&amp;R3;
        if(address == &quot;r4&quot;) return&amp;R4;
        if(address == &quot;e1&quot;) return&amp;E1;
        if(address == &quot;e2&quot;) return&amp;E2;
        if(address == &quot;e3&quot;) return&amp;E3;
        if(address == &quot;e4&quot;) return&amp;E4;
        if(address == &quot;flag&quot;) return&amp;Flag;
        if(address == &quot;val&quot; ) return&amp;Val ;
        if(address == &quot;ret&quot; ) return&amp;Ret ;
        if(address == &quot;line&quot;) return&amp;Line;
    }
    if(address[0] == '@'){ //内存 
        if(address.substr(0,2) == &quot;@%&quot;) return&amp;memory[*get_address(address.substr(1)  )];
        else                            return&amp;memory[ get_int    (address.substr(1),0)];
        //这种码风可能有人看不惯...凑合着看看吧qaq
    }
    if(address[0] == '#'){ //编译时常量 
        address = address.substr(1);
        if(address == &quot;line&quot;){
            undefine = nowline;
            return&amp;undefine;
        }
    }
    
    if(address[0] == '-' || isdigit(address[0])){//常量 
        undefine=get_int(address,0);
        return&amp;undefine;
    }
    
    return NULL;
}

</code></pre>
<h3 id="输入输出">输入输出</h3>
<p>显而易见的，我们可以在读完汇编后停下，在汇编运行时再去读输入输出。</p>
<p>并没有难度。</p>
<p>（<code>read()</code> 就是普通的快读）</p>
<pre><code class="language-cpp">namespace output{
    void wint(string address=&quot;%val&quot;){
        printf(&quot;%d&quot;,*get_address(address));
    }
    void wch(string address=&quot;%val&quot;){
        printf(&quot;%c&quot;,*get_address(address));
    }
}

namespace input{
    void rint(string address=&quot;%val&quot;){
        *get_address(address)=read(); 
    }
    void rch(string address=&quot;%val&quot;){
        string s;cin&gt;&gt;s;
        *get_address(address)=get_int(s,1);
    }
}
</code></pre>
<h3 id="运算命令">运算命令</h3>
<p>对着规范文件打就行了，这一部分相对重复。</p>
<pre><code class="language-cpp">namespace arithmetic{
    void inv (string a0,          string address=&quot;%val&quot; ){*get_address(address) = -(*get_address(a0))                    ;}
    void add (string a0,string a1,string address=&quot;%val&quot; ){*get_address(address) =  (*get_address(a0) +  *get_address(a1));}
    void sub (string a0,string a1,string address=&quot;%val&quot; ){*get_address(address) =  (*get_address(a0) -  *get_address(a1));}
    void mult(string a0,string a1,string address=&quot;%val&quot; ){*get_address(address) =  (*get_address(a0) *  *get_address(a1));}
    void idiv(string a0,string a1,string address=&quot;%val&quot; ){*get_address(address) =  (*get_address(a0) /  *get_address(a1));}
    void mod (string a0,string a1,string address=&quot;%val&quot; ){*get_address(address) =  (*get_address(a0) %  *get_address(a1));}
    void lsft(string a0,string a1,string address=&quot;%val&quot; ){*get_address(address) =  (*get_address(a0) &lt;&lt; *get_address(a1));}
    void rsft(string a0,string a1,string address=&quot;%val&quot; ){*get_address(address) =  (*get_address(a0) &gt;&gt; *get_address(a1));}
    void band(string a0,string a1,string address=&quot;%val&quot; ){*get_address(address) =  (*get_address(a0) &amp;  *get_address(a1));}
    void bor (string a0,string a1,string address=&quot;%val&quot; ){*get_address(address) =  (*get_address(a0) |  *get_address(a1));}
    void bxor(string a0,string a1,string address=&quot;%val&quot; ){*get_address(address) =  (*get_address(a0) ^  *get_address(a1));}
}

namespace logic{
    void lgr (string a0,string a1,string address=&quot;%flag&quot;){*get_address(address) = (bool)(*get_address(a0) &gt;  *get_address(a1));}
    void lls (string a0,string a1,string address=&quot;%flag&quot;){*get_address(address) = (bool)(*get_address(a0) &lt;  *get_address(a1));}
    void lge (string a0,string a1,string address=&quot;%flag&quot;){*get_address(address) = (bool)(*get_address(a0) &gt;= *get_address(a1));}
    void lle (string a0,string a1,string address=&quot;%flag&quot;){*get_address(address) = (bool)(*get_address(a0) &lt;= *get_address(a1));}
    void leql(string a0,string a1,string address=&quot;%flag&quot;){*get_address(address) = (bool)(*get_address(a0) == *get_address(a1));}
    void land(string a0,string a1,string address=&quot;%flag&quot;){*get_address(address) = (bool)(*get_address(a0) &amp;&amp; *get_address(a1));}
    void lor (string a0,string a1,string address=&quot;%flag&quot;){*get_address(address) = (bool)(*get_address(a0) || *get_address(a1));}
} 
</code></pre>
<h3 id="控制命令">控制命令</h3>
<p>控制命令基本也是对着规范文件打就行了，但是要注意规范文件中的那行小字：<br>
注：<code>JMP</code>、<code>JIF</code> 命令会以 <code>%Line</code> 寄存器为偏移跳转（跳转到相加位置），<code>CALL</code> 命令则不会。</p>
<p>考虑到我的代码的后续实现，这里我往系统栈 <code>sAddr</code> 中压的是当前的 <code>%Line</code> 和当前行的序号，如果后续实现和我不一样一定要看清了。</p>
<pre><code class="language-cpp">namespace control{
    void udef(){;}
    void hlt(){exit(0);}
    void nop(){;}
    void set(string a0,string address){
        *get_address(address) = (*get_address(a0));
    }
    void jmp (string a0){
        nowline = (*get_address(a0) + *get_address(&quot;%line&quot;));
    }
    void jif (string a0,string a1=&quot;%flag&quot;){
        if(*get_address(a1)){
            nowline = (*get_address(a0) + *get_address(&quot;%line&quot;));
        }
    }
    void call(string a0){
        sAddr.push(node(nowline,*get_address(&quot;%line&quot;))); //跳转之后还会进入下一行，所以这里存储当前行号就行了
        nowline = (*get_address(a0));
    }
    void ret(string a0=&quot;%ret&quot;){
        *get_address(&quot;%line&quot;) = sAddr.top().Line;
        *get_address(&quot;%ret&quot;) = (*get_address(a0));
        nowline = sAddr.top().nxtline;
        sAddr.pop();
    }
}
</code></pre>
<h3 id="预处理">预处理</h3>
<p>这里的预处理是指删除所有注释以及替换 <code>FUNCTION</code> 命令和 <code>CALLFUNC</code> 命令。</p>
<p>对于注释，可以直接用一些基本字符串操作干掉。</p>
<p>对于 <code>FUNCTION</code> 命令，可以直接用 <code>map</code> 存下该函数的对应行数，然后将原句替换为 <code>set #line %line;</code>。</p>
<p>对于 <code>CALLFUNC</code> 命令，直接在那个 <code>map</code> 里面查到该函数的对应行数，然后将原句替换为 <code>call &lt;对应行数&gt;;</code>。</p>
<pre><code class="language-cpp">namespace special{
    map&lt;string,int&gt; end;
    void function(string a0){
        end[a0]=nowline;
    }
    int callfunc(string a0){
        return end[a0];
    }
}

void init(){
    int notes=0;
    for(int i=1;i&lt;=N;i++){ //去注释
        for(string::iterator j=code[i].begin();j!=code[i].end();){
            if((*j) == '[') notes++;
            if((*j) == ']' &amp;&amp; notes &gt; 0) notes--;
            
            if((*j) == '[' || (*j) == ']' || notes &gt; 0) code[i].erase(j);
            else j++;
        }
    }
    for(nowline=1;nowline&lt;=N;nowline++){
        int posf=code[nowline].find(&quot;function $&quot;);
        if(posf != (int)code[nowline].npos){ //没查到
            sscanf(code[nowline].substr(posf+10).c_str(),&quot;%[^;]&quot;,subcode); //读取函数名，直到遇到分号
            special::function(subcode); //记录该函数的行数
            code[nowline].erase(posf,10+strlen(subcode)); //删除该语句
            code[nowline].insert(posf,&quot;set #line %line&quot;);
        }
    }
    for(nowline=1;nowline&lt;=N;nowline++){
        int posr=code[nowline].find(&quot;callfunc $&quot;);
        if(posr != (int)code[nowline].npos){ //没查到
            sscanf(code[nowline].substr(posr+10).c_str(),&quot;%[^;]&quot;,subcode); //读取函数名，直到遇到分号
            code[nowline].erase(posr,10+strlen(subcode)); //删除该语句
            code[nowline].insert(posr,&quot;call &quot;+get_str(special::callfunc(subcode)));
        }
    }
    return;
}
</code></pre>
<h3 id="运行">运行</h3>
<p>可以考虑将一条命令分为命令名称和参数两个部分，使用 <code>sscanf()</code> 直接读取名称，然后循环读参数，直到读到分号为止。</p>
<p>然后再根据命令名称去执行。</p>
<p>仍然相当繁琐。</p>
<pre><code class="language-cpp">void getcode(){
    for(int i=1;i&lt;=N;i++) getline(cin,code[i]);
    return;
}

char subcode[10005]; //命令名称
char pm[5][10005]; //参数
int pmcnt; //参数个数

void run(){
//    printf(&quot;\&quot;%s\&quot; %d\n&quot;,subcode,pmcnt);
    /*if(nowline == 8){
        printf(&quot;\&quot;%s\&quot; %d:&quot;,subcode,pmcnt);
        for(int i=1;i&lt;=pmcnt;i++){
            printf(&quot;\&quot;%s\&quot; &quot;,pm[i]);
        }
        puts(&quot;&quot;);
    }*/
    
    if(subcode==(string)&quot;udef&quot;) control::udef();
    if(subcode==(string)&quot;hlt&quot;) control ::hlt();
    if(subcode==(string)&quot;nop&quot;) control ::nop();
    if(subcode==(string)&quot;set&quot;) control::set(pm[1],pm[2]);
    if(subcode==(string)&quot;jmp&quot;) control::jmp(pm[1]);
    if(subcode==(string)&quot;jif&quot;){
        if(pmcnt == 1) control::jif(pm[1]);
        if(pmcnt == 2) control::jif(pm[1],pm[2]);
    }
    if(subcode==(string)&quot;call&quot;) control::call(pm[1]);
    if(subcode==(string)&quot;ret&quot;){
        if(pmcnt == 0) control::ret();
        if(pmcnt == 1) control::ret(pm[1]);
    }
    
    
    
    if(subcode==(string)&quot;inv&quot;){
        if(pmcnt == 1) arithmetic::inv(pm[1]);
        if(pmcnt == 2) arithmetic::inv(pm[1],pm[2]);
    }
    if(subcode==(string)&quot;add&quot;){
        if(pmcnt == 2) arithmetic::add(pm[1],pm[2]);
        if(pmcnt == 3) arithmetic::add(pm[1],pm[2],pm[3]);
    }
    if(subcode==(string)&quot;sub&quot;){
        if(pmcnt == 2) arithmetic::sub(pm[1],pm[2]);
        if(pmcnt == 3) arithmetic::sub(pm[1],pm[2],pm[3]);
    }
    if(subcode==(string)&quot;mult&quot;){
        if(pmcnt == 2) arithmetic::mult(pm[1],pm[2]);
        if(pmcnt == 3) arithmetic::mult(pm[1],pm[2],pm[3]);
    }
    if(subcode==(string)&quot;idiv&quot;){
        if(pmcnt == 2) arithmetic::idiv(pm[1],pm[2]);
        if(pmcnt == 3) arithmetic::idiv(pm[1],pm[2],pm[3]);
    }
    if(subcode==(string)&quot;mod&quot;){
        if(pmcnt == 2) arithmetic::mod(pm[1],pm[2]);
        if(pmcnt == 3) arithmetic::mod(pm[1],pm[2],pm[3]);
    }
    if(subcode==(string)&quot;lsft&quot;){
        if(pmcnt == 2) arithmetic::lsft(pm[1],pm[2]);
        if(pmcnt == 3) arithmetic::lsft(pm[1],pm[2],pm[3]);
    }
    if(subcode==(string)&quot;rsft&quot;){
        if(pmcnt == 2) arithmetic::rsft(pm[1],pm[2]);      
        if(pmcnt == 3) arithmetic::rsft(pm[1],pm[2],pm[3]);
    }
    if(subcode==(string)&quot;band&quot;){
        if(pmcnt == 2) arithmetic::band(pm[1],pm[2]);
        if(pmcnt == 3) arithmetic::band(pm[1],pm[2],pm[3]);
    }
    if(subcode==(string)&quot;bor&quot;){
        if(pmcnt == 2) arithmetic::bor(pm[1],pm[2]);
        if(pmcnt == 3) arithmetic::bor(pm[1],pm[2],pm[3]);
    }
    if(subcode==(string)&quot;bxor&quot;){
        if(pmcnt == 2) arithmetic::bxor(pm[1],pm[2]);
        if(pmcnt == 3) arithmetic::bxor(pm[1],pm[2],pm[3]);
    }
    
    
    if(subcode==(string)&quot;lgr&quot;){
        if(pmcnt == 2) logic::lgr(pm[1],pm[2]);
        if(pmcnt == 3) logic::lgr(pm[1],pm[2],pm[3]);
    }
    if(subcode==(string)&quot;lls&quot;){
        if(pmcnt == 2) logic::lls(pm[1],pm[2]);
        if(pmcnt == 3) logic::lls(pm[1],pm[2],pm[3]);
    }
    if(subcode==(string)&quot;lge&quot;){
        if(pmcnt == 2) logic::lge(pm[1],pm[2]);
        if(pmcnt == 3) logic::lge(pm[1],pm[2],pm[3]);
    }
    if(subcode==(string)&quot;lle&quot;){
        if(pmcnt == 2) logic::lle(pm[1],pm[2]);
        if(pmcnt == 3) logic::lle(pm[1],pm[2],pm[3]);
    }
    if(subcode==(string)&quot;leql&quot;){
        if(pmcnt == 2) logic::leql(pm[1],pm[2]);
        if(pmcnt == 3) logic::leql(pm[1],pm[2],pm[3]);
    }
    if(subcode==(string)&quot;land&quot;){
        if(pmcnt == 2) logic::land(pm[1],pm[2]);
        if(pmcnt == 3) logic::land(pm[1],pm[2],pm[3]);
    }
    if(subcode==(string)&quot;lor&quot;){
        if(pmcnt == 2) logic::lor(pm[1],pm[2]);
        if(pmcnt == 3) logic::lor(pm[1],pm[2],pm[3]);
    }
    
    if(subcode==(string)&quot;rint&quot;){
        if(pmcnt == 0) input::rint();
        if(pmcnt == 1) input::rint(pm[1]);
    }
    if(subcode==(string)&quot;rch&quot;){
        if(pmcnt == 0) input::rch();
        if(pmcnt == 1) input::rch(pm[1]);
    }
    if(subcode==(string)&quot;wint&quot;){
        if(pmcnt == 0) output::wint();
        if(pmcnt == 1) output::wint(pm[1]);
    }
    if(subcode==(string)&quot;wch&quot;){
        if(pmcnt == 0) output::wch();
        if(pmcnt == 1) output::wch(pm[1]);
    }
    return;
}

signed main(){
    N=read();
    getcode();
    init();
    
    for(nowline=1;nowline&lt;=N;nowline++){
        int pos=0;
        while(pos&lt;code[nowline].size() &amp;&amp; code[nowline][pos] == ' ') pos++; //跳过开头所有的逗号和空格
        if(pos == code[nowline].size()) continue; //如果是空行就跳过
        sscanf(code[nowline].substr(pos).c_str(),&quot;%[^ ,;]&quot;,subcode); //读取命令名称，直到分号、逗号、空格、三者之一
        pos+=strlen(subcode);
        
        
        while(code[nowline][pos] == ' ' || code[nowline][pos] == ',') pos++; //跳过所有的逗号和空格
        
        pmcnt=0;
        while(code[nowline][pos] != ';'){ //读取参数
            pmcnt++;
            sscanf(code[nowline].substr(pos).c_str(),&quot;%[^ ,;]&quot;,pm[pmcnt]); //读取到分号、逗号、空格、三者之一为止
            pos+=strlen(pm[pmcnt]);
            
            while(code[nowline][pos] == ' ' || code[nowline][pos] == ',') pos++; //跳过所有的逗号和空格
        }
        run();
    }
    /*
    for(int i=1;i&lt;=N;i++){
        cout&lt;&lt;code[i]&lt;&lt;endl;
    }
    */
    return 0;
}
</code></pre>
<p>做完了以上工作，本题便可以成功AC了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解【P6101 出言不逊】]]></title>
        <id>https://hjxhjx-hub.github.io/post/P6101/</id>
        <link href="https://hjxhjx-hub.github.io/post/P6101/">
        </link>
        <updated>2020-04-20T13:31:59.000Z</updated>
        <summary type="html"><![CDATA[<p>作为谔谔Round div.2的第一题，这题还是比较良心的。</p>
]]></summary>
        <content type="html"><![CDATA[<p>作为谔谔Round div.2的第一题，这题还是比较良心的。</p>
<!-- more -->
<p>肥肠适合用来练习基础的<s>码字</s>思维能力。（然而<a href="http://www.luogu.com.cn/user/178480">这个lj</a>还是交满了几页提交记录，让我们一起来嘲讽他吧！）</p>
<p>（话说语文王子看见这题有什么感受）</p>
<p>（语文王子：谔我谔）</p>
<p>扯远了，我继续来讲这题的思路：（大佬们可以跳过这段）</p>
<ol>
<li>
<p>首先，从整个字符串中找出最多的字符 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>；</p>
</li>
<li>
<p>接着将它复制 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 个，放在字符串的后面；</p>
</li>
<li>
<p>如果这句话还是很逊，那么就再找出最多的字符 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>，否则输出；</p>
</li>
<li>
<p>复制；</p>
</li>
<li>
<p>判断&amp;查找；</p>
</li>
</ol>
<p>...</p>
<p>可以算出，这种方法的复杂度大约是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mtext>谔谔</mtext><mo>)</mo></mrow><annotation encoding="application/x-tex">O(\text{谔谔})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord text"><span class="mord cjk_fallback">谔谔</span></span><span class="mclose">)</span></span></span></span>，明显过不了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mo>=</mo><msup><mn>2</mn><mn>64</mn></msup></mrow><annotation encoding="application/x-tex">L=2^{64}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></span> 的这种大数据（虽然不知道有没有）。</p>
<p>如果是这样，我们就要优化它。</p>
<p>仔细观察题面，可以看出，我们其实只用找一次数量最多的字符就可以了。因为在每次操作之后只有之前最多的字符变多了，所以下次操作时最多的字符跟这次找到的字符是同一个。这样就可以把时间压进 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi>s</mi></mrow><annotation encoding="application/x-tex">1s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord mathdefault">s</span></span></span></span> 以内：（大佬们还是可以跳过这段）</p>
<ol>
<li>
<p>首先，从整个字符串中找出最多的字符 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>；</p>
</li>
<li>
<p>接着将它复制 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 个，放在字符串的后面，并执行 <code>x*=2;</code> （因为又新增了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 个这种字符）；</p>
</li>
<li>
<p>如果这句话还是很逊，那么就再复制 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 个，并执行 <code>x*=2</code> ，否则输出；</p>
</li>
<li>
<p>复制 or 输出</p>
</li>
<li>
<p>复制 or 输出</p>
</li>
</ol>
<p>...</p>
<p>这就是本题的要点了。当然还有一些需要注意的地方：（大佬们仍然可以跳过这段）</p>
<ul>
<li><strong>数据很大</strong>，需要int128.</li>
<li>字符串 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span> 中<strong>不全是小写字母</strong>.</li>
<li>在本地运行时要用<code>\n</code>来判断字符串是否读完，<strong>而交上去时要改成<code>\r</code></strong>。(如果你用的是windows)</li>
<li><strong>有可能给出的字符串本来就是不逊的。</strong></li>
</ul>
<p>以上就是整个题目的思路啦，希望能对你有帮助！</p>
<p>你们想要的↓（大佬们依旧可以跳过这段）</p>
<pre><code class="language-cpp">#include &lt;bit\stdc++.cpp&gt;
#define il inlne
#define re register //卡常，然而没用到QAQ
using namespace sd;

il __int128 read(){
    __int128 s=0;
    bool neg=false;
    char ch=getchar();
    while(ch&lt;'0'||ch&gt;'9'){
        if(ch=='-') neg=true;
        ch=getchar();
    }
    while(ch&gt;='0'&amp;&amp;ch&lt;='9'){
        s=(s&lt;&lt;3)+(s&lt;&lt;1)+__int128(ch^48);
        ch=getchar();
    }
    return neg?-s:s;
}

il void print(__int128 x){
    if(x&lt;0) putchar('-'),x=-x;
    if(x&gt;9) print(x/10);
    putchar(x%10+48);
}

__int128 a[150]; //数组开大点
signed main(){
    //freopen(&quot;hjx.in&quot;,&quot;r&quot;,stdin);
    //freopen(&quot;hjx.out&quot;,&quot;w&quot;,stdout);
    __int128 now=0; //已经有的字符数
    char ch=getchar();//输入不讲
    while(ch!='\r'){ //输入，注意是\r而不是\n (比赛时我没翻到那句提示QAQ，越肝越感觉奇怪...但还是玄学A了)
        ch=getchar();
        a[ch]++;
        now++;
    }
    __int128 n=read();//输入
    n=n-now; //求出还需要的字符个数
    if(n&lt;=0){ //特判：如果这句话已经不逊了 我之前在这卡了好久呜呜呜...
        putchar('0'); //输出0
        return 0; //记得return
    }
    __int128 maxn=0;
    for(int i=1;i&lt;=127;i++) maxn=maxn&gt;a[i]?maxn:a[i]; //求出数量最多的字符有多少个。因为 max()不支持int128所以我就手写了一个。
    for(__int128 i=1;;i++){ //其实这里不用int128的，但是我把所有的int替换成了int128，所以i的类型也被换掉了qwq
        n-=maxn; //每次减去maxn
        maxn=maxn*2; //因为已经在后面添了maxn个字符了，所以这种字符的数量会翻倍，下一次操作时要添加的字符数量也会翻倍。
        if(n&lt;=0){ //这句话已经不逊了
            print(i); //输出
            return -1; //不那么华丽的结束
        }
    }
    return 0; //华丽的结束awa
}
</code></pre>
<p><strong>杜绝抄题解，共创美好洛谷</strong></p>
<p>（一道橙题应该没人抄吧）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于]]></title>
        <id>https://hjxhjx-hub.github.io/post/about/</id>
        <link href="https://hjxhjx-hub.github.io/post/about/">
        </link>
        <updated>2020-04-20T12:17:30.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>欢迎来到我的小站呀，很高兴遇见你！🤝</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>欢迎来到我的小站呀，很高兴遇见你！🤝</p>
</blockquote>
<!-- more -->
<h2 id="关于本站">🏠 关于本站</h2>
<p>本站是博主心血来潮，用<a href="https://gridea.dev">Gridea</a>搭建的，在这里安利一下这款软件把搭博客的门槛降低了许多👍👍</p>
<p>本站所用的主题是<a href="https://github.com/hsxyhao/gridea-theme-next">NexT</a>，也超好看的😝</p>
<p>另外，域名是<strong>完全免费</strong>的<a href="https://pages.github.com">github page</a>，也是非常好用的😀</p>
<p>而评论系统则使用的是基于 Github Issue 和 Preact 的评论插件<a href="https://github.com/gitalk/gitalk">gitalk</a>，也要安利一下👍</p>
<p><s>一不小心就安利了四个项目了</s></p>
<h2 id="博主是谁">👨‍💻 博主是谁</h2>
<p>博主叫<strong>hjx</strong>，今年【数据删除】岁，是一名菜鸡OIer</p>
<h2 id="兴趣爱好">⛹ 兴趣爱好</h2>
<ul>
<li>OI（C++）</li>
<li>Minecraft（然而玩了几年还是什么都不会qwq）</li>
</ul>
<h2 id="联系我呀">📬 联系我呀</h2>
<h3 id="邮箱">📪邮箱</h3>
<ul>
<li>📧邮箱1：<a href="mailto:hjx__hjx2@163.com">hjx__hjx2@163.com</a></li>
<li>📧邮箱2：<a href="mailto:hjxhjx2@qq.com">hjxhjx2@qq.com</a></li>
</ul>
<h3 id="账号">🔍账号：</h3>
<p><strong>洛谷：</strong><br>
<a href="http://www.luogu.com.cn/user/178480">178480</a></p>
<p><strong>QQ：</strong><br>
<a href="http://wpa.qq.com/msgrd?v=3&amp;uin=672837223&amp;site=qq&amp;menu=yes">672837223</a></p>
<p><strong>B站：</strong><br>
<a href="http://space.bilibili.com/446092525">446092525</a></p>
<p><strong>mcbbs：</strong><br>
<a href="http://www.mcbbs.net/home.php?mod=space&amp;uid=3148250">hjxhjx2</a></p>
<p>以及还有更多账号，因为太丢脸了所以没放上来qaq</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://hjxhjx-hub.github.io/post/hello-gridea/</id>
        <link href="https://hjxhjx-hub.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>